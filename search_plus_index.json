{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction This is whuwzp's remotecontrol wiki! 主要是用Go仿写Python远控项目. Copyright © whuwzp.top 2018 all right reserved，powered by Gitbook本文档修订时间： 2018-07-12 22:16:18 "},"1.html":{"url":"1.html","title":"slave端","keywords":"","body":"title: Go-远程控制项目(1)-slave端 date: 2018-04-12 18:35:33 tags: [go, 语言] categories: 科研 大神(github帐号: kingname), 项目源码地址:https://github.com/kingname/RemoteControl/ , 用python实现远程控制。本项目是想采用Go语言实现类似的远程控制。本节是粗写slave端。 项目 TEST1-字符串匹配 以打开计算器为例。 package main import ( \"net\" \"fmt\" \"strings\" \"os/exec\" \"log\" ) var ( DATA = make([]string, 4096) ) func main() { conn, err := net.Dial(\"tcp\", \"127.0.0.1:5000\") defer conn.Close() if err != nil { panic(err) } buf := make([]byte,4096) for { length, _ := conn.Read(buf) //delete \"#finished#\" data := string(buf[0:length-10]) fmt.Println(\"recv data :\",data) index := strings.Index(data, \"\\\"command\\\"\") //find and get the command fmt.Println(\"command:\", data[index+12:length-12]) cmd := exec.Command(data[index+12:length-12]) err := cmd.Start() if err != nil { log.Fatal(err) } } } TEST2-正则表达式匹配 将上一步中的字符串查找替换为正则表达式用于检测command。 package main import ( \"net\" \"fmt\" \"os/exec\" \"log\" \"regexp\" ) var ( DATA = make([]string, 4096) ) func main() { conn, err := net.Dial(\"tcp\", \"127.0.0.1:5000\") defer conn.Close() if err != nil { panic(err) } buf := make([]byte,4096) for { length, _ := conn.Read(buf) //delete \"#finished#\" data := string(buf[0:length-10]) fmt.Println(\"recv data :\",data) CmdString := analyseCommand(data) fmt.Println(\"cmd:\", CmdString) cmd := exec.Command(CmdString) err := cmd.Start() if err != nil { log.Println(err) } } } func analyseCommand(data string) string { re := regexp.MustCompile(`\"command\":[^\"]+\"([^\"]+)\"`) match := re.FindStringSubmatch(data) //match[1] is the command return match[1] } TEST3-考虑多参量命令 由于上一步中输入命令只能是calc这样系统程序，并且只能是一个指令，也就是无法执行带参量的程序，这样一来就会很受限，因为我们还希望对文件进行操作，python运行脚本等。经过研究发现exec.Command是需要指令和参量（Args）的，而这里的远程控制是将整个字符串传递过来的，所以我们需要进行切分，显然切分是空格分隔开，因此有了下一版本。 package main import ( \"net\" \"fmt\" \"os/exec\" \"log\" \"regexp\" ) var ( DATA = make([]string, 4096) ) func main() { conn, err := net.Dial(\"tcp\", \"127.0.0.1:5000\") defer conn.Close() if err != nil { panic(err) } buf := make([]byte,4096) for { length, _ := conn.Read(buf) //delete \"#finished#\" data := string(buf[0:length-10]) fmt.Println(\"recv data :\",data) CmdString, args := analyseCommand(data) fmt.Println(\"cmd:\", CmdString) cmd := exec.Command(CmdString, args) err := cmd.Start() if err != nil { log.Println(err) } } } func analyseCommand(data string) (string, string) { //新增了找出参量部分 re := regexp.MustCompile(`\"command\":[^\"]+\"([^ ]+) ([^\"]+)\"`) match := re.FindStringSubmatch(data) fmt.Println(match) //match[1] is the command return match[1], match[2] } 这里输入命令python ....py进行测试，测试成功。需要注意的是该可执行脚本必须是可视化的，否则不好检测是否成功。 TEST4-考虑无参量和多参量命令情形 上一步中的方法对无参量命令不可用了，因为无参量时上述正则表达式找不到任何的匹配项（因为没有空格），所以不能这样全匹配。然后想到了split函数，用空格符将字符串分段。 package main import ( \"net\" \"fmt\" \"os/exec\" \"log\" \"regexp\" \"strings\" ) var ( DATA = make([]string, 4096) ) func main() { conn, err := net.Dial(\"tcp\", \"127.0.0.1:5000\") defer conn.Close() if err != nil { panic(err) } buf := make([]byte,4096) for { length, _ := conn.Read(buf) //delete \"#finished#\" data := string(buf[0:length-10]) fmt.Println(\"recv data :\",data) analyseCommand(data) } } func analyseCommand(data string){ re := regexp.MustCompile(`\"type\":[^\"]+\"([^\"]+)\".+\"command\":[^\"]+\"([^\"]+)\"`) match := re.FindStringSubmatch(data) fmt.Println(\"match:\", match[1:]) //区别command类型 cmdType, cmdString := match[1], match[2] if cmdType == \"commandInConfig\" { //利用split函数分割命令和参量 cmdAndarg := strings.Split(cmdString, \" \") Cmd, arg := cmdAndarg[0], cmdAndarg[1] exeCommand(Cmd, arg) } else if cmdType == \"commandInWrite\" { writeCommand() } else { log.Println(\"command type error! please input right command\") } } //for example: python test.py func exeCommand(Cmd string, arg string) { fmt.Printf(\"cmd: %s , arg: %s\", Cmd, arg) cmd := exec.Command(Cmd, arg) err := cmd.Start() if err != nil { log.Println(err) } } func writeCommand(){ fmt.Println(\"going to write code...\") } TEST5-完成了python代码写入文件 由于字符串中转义字符，写入后无法当作换行符，这个需要进一步考虑。 另一方面，python中'u'等字符串方法可以很方便的进行字符串操作。 package main import ( \"fmt\" \"net\" \"log\" \"os/exec\" \"regexp\" \"os\" \"strings\" ) var ( DATA = make([]string, 4096) ) func main() { conn, err := net.Dial(\"tcp\", \"127.0.0.1:5000\") if err != nil { panic(err) } defer conn.Close() buf := make([]byte, 4096) for { length, _ := conn.Read(buf) //delete \"#finished#\" data := string(buf[0 : length-10]) fmt.Println(\"recv data :\", data) analyseCommand(data) } } func analyseCommand(data string) { re := regexp.MustCompile(`\"type\":[^\"]+\"([^\"]+)\".+\"command\":[^\"]+\"([^\"]+)\"`) match := re.FindStringSubmatch(data) fmt.Println(\"match:\", match[1:]) cmdType, cmdString := match[1], match[2] if cmdType == \"commandInConfig\" { cmdAndarg := strings.Split(cmdString, \" \") Cmd, arg := cmdAndarg[0], cmdAndarg[1] exeCommand(Cmd, arg) } else if cmdType == \"commandInWrite\" { writeCommand(cmdString) } else { log.Println(\"command type error! please input right command\") } } //for example: python test.py func exeCommand(Cmd string, arg string) { fmt.Printf(\"cmd: %s , arg: %s\\n\", Cmd, arg) cmd := exec.Command(Cmd, arg) fmt.Println(\"going to exe command...\") err := cmd.Start() if err != nil { log.Println(err) } } func writeCommand(cmdString string) { fmt.Println(\"going to write code...\") f, err := os.Create(\"python.py\") if err != nil{ log.Println(err) } defer f.Close() //cmdString = strings.Replace(cmdString, `\\n`, `\\r\\n`, -1) f.WriteString(cmdString) fmt.Println(\"writing code:\", cmdString) fmt.Println(\"writen!\") } 附录 其他知识点 if else格式 if num := 9; num 文件操作 博客地址：https://studygolang.com/articles/2073 f, err3 := os.Create(\"./output3.txt\") //创建文件 check(err3) defer f.Close() n2, err3 := f.Write(d1) //写入文件(字节数组) check(err3) fmt.Printf(\"写入 %d 个字节n\", n2) n3, err3 := f.WriteString(\"writesn\") //写入文件(字节数组) fmt.Printf(\"写入 %d 个字节n\", n3) f.Sync() Copyright © whuwzp.top 2018 all right reserved，powered by Gitbook本文档修订时间： 2018-04-22 10:24:53 "},"2.html":{"url":"2.html","title":"server端","keywords":"","body":"title: Go-远程控制项目(2)-server端 date: 2018-04-20 18:35:33 tags: [go, 语言] categories: 科研 大神(github帐号: kingname), 项目源码地址:https://github.com/kingname/RemoteControl/ , 用python实现远程控制。本项目是想采用Go语言实现类似的远程控制。本节是粗写server端。 项目 TEST1-完成listslave功能 package main import ( \"net\" \"fmt\" \"regexp\" \"log\" \"sync\" \"strings\" ) const ( bufsize = 4096*100 MASTER = \"master\" SLAVE = \"slave\" SERVER = \"server\" ) var ( slaveConnPool []net.Conn masterConn net.Conn mu sync.Mutex ) func main() { listen, err := net.Listen(\"tcp\",\"127.0.0.1:5000\") if err != nil { panic(err) } for { conn, err := listen.Accept() if err != nil { panic(err) } fmt.Println(\"========================\\na new conn: \", conn.RemoteAddr().String()) AddslaveConnPool(conn) go handleConn(conn) } defer listen.Close() } func handleConn(c net.Conn) { defer c.Close() for { buf := make([]byte, bufsize) nbyte, err := c.Read(buf) if err != nil { log.Printf(\"the socker has been closed by the %s\", c.RemoteAddr().String()) break } fmt.Println(\"recv data:\", string(buf[:nbyte])) to, from, cmdString, cmdType := analyseCommand(string(buf[:nbyte])) fmt.Printf(\"from: %s, to: %s, cmd: %s, type: %s\\n\", from, to ,cmdString, cmdType) //add to slavepool if from == MASTER { masterConn = c //delete the master conn from pool DelslaveConnPool(c) dispatch(to, from, cmdString, cmdType) } else { log.Println(\"don't know who send this message\") } } } func AddslaveConnPool(c net.Conn) { mu.Lock() defer mu.Unlock() slaveConnPool = append(slaveConnPool, c) fmt.Println(\"conn pool :\", slaveConnPool) } func DelslaveConnPool(c net.Conn) { mu.Lock() defer mu.Unlock() //fmt.Println(\"pool before delete\", slaveConnPool) var pool []net.Conn for _, v := range slaveConnPool { if v == c { } else { pool = append(pool, v) } } slaveConnPool = pool //fmt.Println(\"pool after delete\", slaveConnPool) } //return to, from, cmdString and cmdType func analyseCommand(data string) ( _,_,_,_ string) { //re := regexp.MustCompile(`\"to\"[^\"]+\"([^\"]+)\"[^\"]+\"from\"[^\"]+\"([^\"]+)\"[^\"]+\"command\"[^\"]+\"([^\"+])\"[^\"]+\"type\"[^\"]+\"([^\"]+)\".+`) re := regexp.MustCompile(`\"to\"[^\"]+\"([^\"]*)\"[^\"]+\"from\"[^\"]+\"([^\"]*)\"[^\"]+\"command\"[^\"]+\"([^\"]*)\"[^\"]+\"type\"[^\"]+\"([^\"]*)\"`) match := re.FindStringSubmatch(data) if len(match) TEST2-完成发送命令 package main import ( \"net\" \"fmt\" \"regexp\" \"log\" \"sync\" \"strings\" ) const ( bufsize = 4096*100 MASTER = \"master\" SLAVE = \"slave\" SERVER = \"server\" ) var ( slaveConnPool []net.Conn masterConn net.Conn mu sync.Mutex ) func main() { listen, err := net.Listen(\"tcp\",\"127.0.0.1:5000\") if err != nil { panic(err) } for { conn, err := listen.Accept() if err != nil { panic(err) } fmt.Println(\"========================\\na new conn: \", conn.RemoteAddr().String()) AddslaveConnPool(conn) go handleConn(conn) } defer listen.Close() } func handleConn(c net.Conn) { defer c.Close() for { buf := make([]byte, bufsize) nbyte, err := c.Read(buf) if err != nil { log.Printf(\"the socker has been closed by the %s\", c.RemoteAddr().String()) break } fmt.Println(\"recv data:\", string(buf[:nbyte])) to, from, cmdString, cmdType := analyseCommand(string(buf[:nbyte])) fmt.Printf(\"from: %s, to: %s, cmd: %s, type: %s\\n\", from, to ,cmdString, cmdType) //add to slavepool if from == MASTER { masterConn = c //delete the master conn from pool DelslaveConnPool(c) dispatch(to, from, cmdString, cmdType) } else { log.Println(\"don't know who send this message\") } } } func AddslaveConnPool(c net.Conn) { mu.Lock() defer mu.Unlock() slaveConnPool = append(slaveConnPool, c) fmt.Println(\"conn pool :\", slaveConnPool) } func DelslaveConnPool(c net.Conn) { mu.Lock() defer mu.Unlock() //fmt.Println(\"pool before delete\", slaveConnPool) var pool []net.Conn for _, v := range slaveConnPool { if v == c { } else { pool = append(pool, v) } } slaveConnPool = pool //fmt.Println(\"pool after delete\", slaveConnPool) } //return to, from, cmdString and cmdType func analyseCommand(data string) ( _,_,_,_ string) { //re := regexp.MustCompile(`\"to\"[^\"]+\"([^\"]+)\"[^\"]+\"from\"[^\"]+\"([^\"]+)\"[^\"]+\"command\"[^\"]+\"([^\"+])\"[^\"]+\"type\"[^\"]+\"([^\"]+)\".+`) re := regexp.MustCompile(`\"to\"[^\"]+\"([^\"]*)\"[^\"]+\"from\"[^\"]+\"([^\"]*)\"[^\"]+\"command\"[^\"]+\"([^\"]*)\"[^\"]+\"type\"[^\"]+\"([^\"]*)\"`) match := re.FindStringSubmatch(data) if len(match) 附录 后期事项 事项1-数据类型 由于python和go数据类型上的不同，python中发的都是字典形式的，如： {\"to\": \"\", \"from\": \"master\", \"command\": \"listSlave\", \"type\": \"\"} 这在python中很容易键值对找到，但是到了go就必须得翻译，所以后期等整个完成了，需要把数据类型改换成更适合go语言，这样效率更高。 事项2-初始化角色确认 现在还没分析清楚python中如何确定slave和master的角色，后期写代码需要注意在初始化连接时，看如何确认。现在listSlave返回的都是全部的，由master确定（它知道自己是哪个）。 事项3-goroutine 每个连接都是一个goroutine，只需要记下slave的conn就好，master的不太需要，因为不可能由slave发给master，所以slave的conn（goroutine）不会跨conn向master的conn发送消息。而master发给slave的则可以用slavepool找到（并且消息的to字段决定了发给谁）。 事项4-socket关闭 这个人写的python会自动关闭socket，而每次发送时会新建连接，这样就不能永久使用MasterConn. 事项5-发送数据 masterConn.Write([]byte(message)) 相关知识 Read接口的使用 buf := make([]byte, 4096) //应该是把conn中接收的数据写入到了buf中 nbyte, err := c.Read(buf) //返回的是接收数据的长度 if err != nil { panic(err) } //打印数据 fmt.Println(\"recv data:\", string(buf[:nbyte])) if else格式 if num := 9; num Copyright © whuwzp.top 2018 all right reserved，powered by Gitbook本文档修订时间： 2018-04-22 10:24:53 "},"3.html":{"url":"3.html","title":"重写项目","keywords":"","body":"title: Go-远程控制项目(3)-重写项目 date: 2018-04-20 18:35:33 tags: [go, 语言] categories: 科研 参照之前的，重写了go下的远程控制，明确了消息格式，发送接收函数等。本项目地址：github.com/whuwzp/RemoteControl/ 仿写的master端的代码就不再贴了，在我的GitHub中将提供了这些代码，分别为1.0，2.0，3.0，其中1.0为仿写，完成了执行命令，2.0完成了回传（但是，仍然是在之前的架构下写的），3.0为重写部分，重写了消息格式等。 实现目标 实现被控端（slave）、中间反弹端（server）和控制端（master）的控制架构，其中被控端可以是多个主机； 实现master经由server控制slave执行程序和python脚本（以系统自带的计算器为例），如果cmdshell中有信息（如ipconfig），则回传master端； 实现master经由server控制slave写文件（以写入python脚本为例）； 实现master经由server控制slave传输文件（以传输a.txt文件为例，但是为空？）； 木马自启动（尚未完成）。 实验环境 OS：win10 编程语言：Go语言（版本：1.9.2） 实验原理 反弹式架构 主要是由slave、master统一连接server端实现。 server端，绑定监听127.0.0.1:5000，并接收连接： listen, err := net.Listen(\"tcp\", \"127.0.0.1:5000\") conn, err := listen.Accept() master和slave端，连接server的127.0.0.1:5000： conn, err := net.Dial(\"tcp\", \"127.0.0.1:5000\") 消息协议 为了方便解析和统一格式，采用了json格式将发送的消息进行了格式化。其中，消息的结构体为： type Message struct { From string //发送方 To string //接收方 Type string //消息类型 Cmd string //指令 Args string //指令参数 } const ( MASTER = \"master\" SLAVE = \"slave\" SERVER = \"server\" TYPECMD = \"cmd\" TYPECODE = \"code\" TYPEDATA = \"data\" ) From 可以是MASTER, SERVER, \"127.0.0.1:41431\"，分别表示控制端，服务端和连接地址为127.0.0.1:41431的slave； To 同From Type TYPECMD，表示发送的是指令，Cmd为指令，Args为指令参数（可为空）； TYPECODE，表示发送的是待写入的代码，此时Cmd为空，Args为代码内容； TYPEDATA，表示发送的是文件请求，此时Cmd为空，Args为文件名。 Cmd 指令，如\"calc\"表示计算器，\"python\"表示执行python（需配置环境变量），\"listslave\"命令是向server查询现在在线的slave信息； Args 指令参数，或者数据（代码），以及响应的cmdshell中的信息。 构造消息后，用json的MarshalIndent和Unmarshal函数，格式化和解析。 data, err := json.MarshalIndent(m, \"\", \" \") err := json.Unmarshal(data, &m) 代码如下： package message import ( \"encoding/json\" \"fmt\" \"log\" \"net\" \"os\" \"io\" ) type Message struct { From string To string Type string Cmd string Args string } func SendMsg(c net.Conn, m Message) { data, err := json.MarshalIndent(m, \"\", \" \") if err != nil { log.Fatalf(\"JSON marshaling failed: %s\", err) } c.Write(data) } func RecvMsg(c net.Conn, buf []byte) Message { nbyte, err := c.Read(buf) if err != nil { log.Fatal(\"recving msg error: \", err) } fmt.Println(\"recv data :\", string(buf[:nbyte])) return AnalyseMsg(buf[:nbyte]) } func AnalyseMsg(data []byte) Message { var m Message err := json.Unmarshal(data, &m) if err != nil { log.Fatalf(\"JSON unmarshaling failed: %s\", err) } return m } func RecvFile(c net.Conn, fn string){ f,err := os.Create(fn) if err!=nil{ log.Fatal(\"open file error:\", err) } finfo, _ := os.Lstat(fn) io.CopyN(f, c, finfo.Size()) } func SendFile(c net.Conn, fn string){ f,err := os.Open(fn) if err!=nil{ log.Fatal(\"open file error:\", err) } finfo, _ := os.Lstat(fn) io.CopyN(c, f, finfo.Size()) } func TransFile(src, dst net.Conn){ io.CopyN(src, dst, 4) } server端 server主要负责以下内容： 维护slaveConnPool，slave的连接信息； 响应master的listslave请求（获取当前在线的slave端）； 接收slave和master的消息，由dispatch分流，根据消息的from和to字段分类进行处理（多数根据to信息直接转发）； 完整代码如下： package main import ( \"fmt\" \"github.com/whuwzp/RemoteControl/RemoteControl/message\" \"net\" \"sync\" ) const ( bufsize = 4096 * 100 MASTER = \"master\" SLAVE = \"slave\" SERVER = \"server\" TYPECMD = \"cmd\" TYPECODE = \"code\" TYPEDATA = \"data\" ) var ( slaveConnPool []net.Conn masterConn net.Conn mu sync.Mutex ) func main() { listen, err := net.Listen(\"tcp\", \"127.0.0.1:5000\") if err != nil { panic(err) } for { conn, err := listen.Accept() if err != nil { panic(err) } fmt.Println(\"========================\\na new conn: \", conn.RemoteAddr().String()) AddslaveConnPool(conn) go handleConn(conn) } defer listen.Close() } func handleConn(c net.Conn) { defer c.Close() for { buf := make([]byte, bufsize) RecvMsg := message.RecvMsg(c, buf) //delete the master conn from pool if RecvMsg.From == \"master\" { masterConn = c DelslaveConnPool(c) } dispatch(RecvMsg) } } func AddslaveConnPool(c net.Conn) { mu.Lock() defer mu.Unlock() slaveConnPool = append(slaveConnPool, c) fmt.Println(\"conn pool :\", slaveConnPool) } func DelslaveConnPool(c net.Conn) { mu.Lock() defer mu.Unlock() //fmt.Println(\"pool before delete\", slaveConnPool) var pool []net.Conn for _, v := range slaveConnPool { if v == c { } else { pool = append(pool, v) } } slaveConnPool = pool //fmt.Println(\"pool after delete\", slaveConnPool) } func dispatch(m message.Message) { if m.To == MASTER { slave2master(m) } else if m.To == SERVER { master2server(m) } else { master2slave(m) } } func slave2master(m message.Message) { message.SendMsg(masterConn, m) } func master2slave(m message.Message) { for _, c := range slaveConnPool { if c.RemoteAddr().String() == m.To { if m.Type == TYPEDATA{ message.SendMsg(c, m) message.TransFile(c, masterConn) } else { message.SendMsg(c, m) } break } } } func master2server(m message.Message) { var msg message.Message if m.Cmd == \"listslave\" { msg = message.Message{ SERVER, MASTER, TYPEDATA, \"\", string(listslave()), } } message.SendMsg(masterConn, msg) } func listslave() string { mu.Lock() defer mu.Unlock() var list string for _, c := range slaveConnPool { list += (c.RemoteAddr().String() + \" \") } fmt.Println(\"list:\", list) return list } master端 master端比较简单，就是输入消息中的各个元素，并根据消息类型（向slave写入数据，即TYPECODE）和具体指令（是否需要等待回复，如VoidCmd中的为不要回复的）进行消息发送和接收。 package main import ( \"fmt\" \"net\" //\"regexp\" //\"os\" //\"encoding/json\" \"github.com/whuwzp/RemoteControl/RemoteControl/message\" ) const ( MASTER = \"master\" SLAVE = \"slave\" SERVER = \"server\" TYPECMD = \"cmd\" TYPECODE = \"code\" TYPEDATA = \"data\" ) var VoidCmd []string func init() { VoidCmd = []string{\"python\", \"calc\"} } func main() { conn, err := net.Dial(\"tcp\", \"127.0.0.1:5000\") if err != nil { panic(err) } defer conn.Close() buf := make([]byte, 4096) flag := false for { flag = false m := GetCmd() fmt.Println(\"starting to send msg...\") for _, v := range VoidCmd { if m.Cmd == v { //sending message.SendMsg(conn, m) flag = true break } } if !flag { if m.Type == TYPEDATA{ message.SendMsg(conn, m) fmt.Println(\"starting to recv file...\") message.RecvFile(conn, m.Args) }else { message.SendMsg(conn, m) fmt.Println(\"starting to recv msg...\") RecvMsg := message.RecvMsg(conn, buf) fmt.Println(RecvMsg.Args) } } } } func GetCmd() message.Message { var from, to, cmdtype, cmd, args string //from from = MASTER //to fmt.Println(\"please select your slave (or 0: server): \") fmt.Scanln(&to) if to == \"0\" { to = SERVER } //type fmt.Println(\"please select your command type: \\n\" + \"0: execCmd\\n\" + \"1: writeCode\\n\" + \"2: Data\") fmt.Scanln(&cmdtype) if cmdtype == \"0\" { cmdtype = TYPECMD } else if cmdtype == \"1\" { cmdtype = TYPECODE } else { cmdtype = TYPEDATA } //cmd fmt.Println(\"please input your command: (0: listslave)\") fmt.Scanln(&cmd) if cmd == \"0\" { cmd = \"listslave\" } //args fmt.Println(\"please input your command args: \") fmt.Scanln(&args) return message.Message{from, to, cmdtype, cmd, args} } slave端 slave端也需要解析消息，根据消息类型和具体指令进行分流处理dispatch，分流消息至特定的处理函数，如执行命令，写python脚本等； 完整代码如下： package main import ( \"fmt\" \"net\" \"log\" \"os/exec\" \"bufio\" \"io\" \"os\" \"github.com/whuwzp/RemoteControl/RemoteControl/message\" ) const ( bufsize = 4096 * 100 MASTER = \"master\" SLAVE = \"slave\" SERVER = \"server\" TYPECMD = \"cmd\" TYPECODE = \"code\" TYPEDATA = \"data\" ) var ( DATA = make([]string, 4096) conn net.Conn ) func main() { var err error conn, err = net.Dial(\"tcp\", \"127.0.0.1:5000\") if err != nil { panic(err) } defer conn.Close() buf := make([]byte, 4096) for { RecvMsg := message.RecvMsg(conn, buf) dispatch(RecvMsg) } } func dispatch(m message.Message) { if m.Type == TYPECMD { msg := execCommand(m.Cmd, m.Args) RespMsg := message.Message{ From: SLAVE, To: MASTER, Type: TYPECMD, Cmd: \"\", Args: msg, } message.SendMsg(conn, RespMsg) } else if m.Type == TYPECODE { writeCommand(m.Args) } else { //file message.SendFile(conn, m.Args) } } //for example: python test.py func execCommand(Cmd string, arg string) string { cmd := exec.Command(Cmd, arg) fmt.Println(\"going to exe command...\") //显示运行的命令 fmt.Println(cmd.Args) stdout, err := cmd.StdoutPipe() if err != nil { fmt.Println(err) } cmd.Start() reader := bufio.NewReader(stdout) msg := \"\" //实时循环读取输出流中的一行内容 for { line, err2 := reader.ReadString('\\n') if err2 != nil || io.EOF == err2 { break } msg += line } fmt.Println(msg) cmd.Wait() return msg } func writeCommand(code string) { fmt.Println(\"going to write code...\") f, err := os.Create(\"python.py\") if err != nil { log.Println(err) } defer f.Close() f.WriteString(code) fmt.Println(\"writing code:\", code) fmt.Println(\"writen!\") } func fileCommand(filename string){ } 核心功能 执行命令 cmd := exec.Command(Cmd, arg) cmd.Start() cmdshell信息回传 主要是以下方法： cmd := exec.Command(Cmd, arg) stdout, err := cmd.StdoutPipe() cmd.Start() reader := bufio.NewReader(stdout) msg := \"\" //实时循环读取输出流中的一行内容 for { line, err2 := reader.ReadString('\\n') if err2 != nil || io.EOF == err2 { break } msg += line } fmt.Println(msg) cmd.Wait() return msg 文件传输 这主要利用了io.copyN函数: func CopyN(dst Writer, src Reader, n int64) 其中，因为net.Conn和os.File都完成了Writer，Reader的接口，因此可以作为其实例。具体步骤思路是: slave端：CopyN(Conn, file, n int64) ，这里的Conn是slave和server的连接，file就是待传输的文件，n为文件大小，由os.fileinfo可获取； server端：CopyN(masterConn, Conn, n int64) ，这里的masterConn是server和master的连接，Conn是slave和server的连接； master端：CopyN(file, masterConn, n int64) ，这里的masterConn是server和master的连接，file就是master接收后的文件。 实验结果展示 获取slave 执行指令（以calc计算器为例） 我们向127.0.0.1:12296（slave）发送了calc 指令，server端也显示转发这条指令到slave，结果运行起了计算器： 写python代码 我们向slave端写了内容为hello的python脚本，可以看到在slave.exe的文件目录下，生产了python.py，其内容为hello。 传输文件 我们将slave目录下的a.txt传输到了master中。（这里还没完善，应该先获取目录文件，这里我们默认是已知了有这个文件）。 Copyright © whuwzp.top 2018 all right reserved，powered by Gitbook本文档修订时间： 2018-06-06 18:27:35 "}}